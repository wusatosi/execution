<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>beman::execution: intro-examples</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
 <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
 <script type="text/javascript">
     DoxygenAwesomeDarkModeToggle.init()
 </script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="beman-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">beman::execution
   </div>
   <div id="projectbrief">Building Block For Asynchronous Programs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_docs_intro_examples.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">intro-examples </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md1"></a>
Introduction by Example</h1>
<p>This page provides a series of examples showing how to use the <code>std::execution</code> components.</p>
<details >
<summary >
<code>"Hello, world"</code> - synchronous using asynchronous components</summary>
<p></p>
<p>Code: [<code>examples/intro-1-hello-world.cpp</code>]() </p><div class="fragment"><div class="line"><span class="comment">// examples/intro-1-hello-world.cpp                                   -*-C++-*-</span></div>
<div class="line"><span class="comment">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;beman/execution/execution.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;tuple&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>ex = ::beman::execution;</div>
<div class="line"><span class="keyword">using namespace </span>std::string_literals;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ----------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">// Please see the explanation in docs/intro-examples.md for an explanation.</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// clang-format off</span></div>
<div class="line">     <span class="keyword">auto</span> [result] = ex::sync_wait(</div>
<div class="line">         ex::when_all(</div>
<div class="line">             ex::just(<span class="stringliteral">&quot;hello, &quot;</span>s),</div>
<div class="line">             ex::just(<span class="stringliteral">&quot;world&quot;</span>s)</div>
<div class="line">         ) | ex::then([](<span class="keyword">auto</span> s1, <span class="keyword">auto</span> s2) { <span class="keywordflow">return</span> s1 + s2; })</div>
<div class="line">         ).value_or(std::tuple(<span class="stringliteral">&quot;&quot;</span>s)</div>
<div class="line">     );</div>
<div class="line">    <span class="comment">// clang-format on</span></div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; result &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The first example is a very complicated way to a version of <code>"Hello,
world"</code>: it uses components for dealing with asynchronous work to synchronously produce the result. The intention is to show a basic use of some involved components to build up a feeling of how things work.</p>
<p>The componentes for <code>std::execution</code> are declared in the header <code>&lt;execution&gt;</code>. This particular implementation implements the cmponents in namespace <code><a class="el" href="namespacebeman_1_1execution.html" title="Namespace for asynchronous operations and their vocabulary.">beman::execution</a></code> declared in the header <code>&lt;<a class="el" href="execution_2execution_8hpp_source.html">beman/execution/execution.hpp</a>&gt;</code>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;beman/execution/execution.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;tuple&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>ex = ::beman::execution;</div>
<div class="line"><span class="keyword">using namespace </span>std::string_literals;</div>
</div><!-- fragment --><p>Most of these declarations should be familiar. The namespace alias <code>ex</code> is used to support easy migration to a different implementation, in particular the standard name <code>std::execution</code> once it becomes available with standard library implementations. The other examples will have a similar start which is only mentioned in the explanation to point out unusual parts like the use of custom components.</p>
<p>All interesting work happens in the <code>main</code> function:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span>[result] = ex::sync_wait(</div>
<div class="line">        ex::when_all(</div>
<div class="line">            ex::just(<span class="stringliteral">&quot;hello, &quot;</span>s),</div>
<div class="line">            ex::just(<span class="stringliteral">&quot;world&quot;</span>s)</div>
<div class="line">        )</div>
<div class="line">        | ex::then([](<span class="keyword">auto</span> s1, <span class="keyword">auto</span> s2){ <span class="keywordflow">return</span> s1 + s2; })</div>
<div class="line">        ).value_or(std::tuple(<span class="stringliteral">&quot;&quot;</span>s));</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; result &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>This code code be simpler even when using components from <code>std::execution</code>. Showing a few more components is intended to better reflect how an asynchronous program might look like. This examples uses a <em>sender factory</em> (<code>ex::just</code>), two <em>sender adaptors</em> (<code>ex::when_all</code> and <code>ex::then</code>), and finally a <em>sender consumer</em> (<code>ex::sync_wait</code>) to build up work and to execute it. The idea of a <em>sender</em> is that it represents work which can be composed with algorithms into a unit of work which is eventually executed.</p>
<p>Each work item can complete asynchronously at some later time, i.e., calling it like a function and using a returned value isn't really an option. Instead, when the work is started it does whatever is needed to get the work completed and get a <em>completion signal</em> delivered. Delivering a completion signal consists of calling a function on a suitable objects. The important part is that once work is started it always delivers exactly one completion signal which can indicate success, failure, or cancellation. Later examples for creating senders will go into more details about the cancellation signals.</p>
<p>The components used in this example do all of that synchronously:</p>
<ul>
<li><code>ex::just("string"s)</code> completes immediately when started with successful completion which includes the string passed as argument.</li>
<li><code>ex::when_all(<em>sender1</em>, <em>sender2</em>)</code> starts the senders passed as arguments. When all of the senders complete, it produces its own completion. In the case of success all the received values are passed to the completion signal. In case of an error all outstanding work is cancelled and the first error becomes <code>when_all</code>'s completion signal once all children have completed. Similarly, in case of cancellation all children get cancelled and once all complete <code>when_all</code> produces a cancellation signal. In the example the two children each produces one string as completion signal and <code>when_all</code> produces these two strings as its completion signal.</li>
<li><code><em>sender</em> | ex::then(<em>fun</em>)</code> is equivalent to using <code>ex::then(<em>sender</em>, <em>fun</em>)</code>. The <code>ex::then</code> calls the function <code><em>fun</em></code> with its child sender completes successful. The arguments to <code><em>fun</em></code> are the values received from the child completion signal. In the example, the child is <code>when_all(...)</code> and it produces two strings which are passed to <code><em>fun</em></code>. The completion signal of <code>ex::then</code> is successful with the value returned from the call to <code><em>fun</em></code> (which may <code>void</code>) if the call returns normally. If an exception is thrown <code>ex::then</code> completes with an <code>std::exception_ptr</code> to the exception thrown. In the example the completion is just a concatenation of the two strings.</li>
<li><code>sync_wait(<em>sender</em>)</code> starts its argument and then blocks until the work completes although the thread calling <code>sync_wait</code> may contribute to the completion of the work. The function returns a an <code>std::optional&lt;std::tuple&lt;<em>results</em>...&gt;&gt;</code>&gt;. If the child sender completes successfully the values from the child's completion signal become the elements of the tuple. If the child completes with an error, the error is thrown as an exception. Otherwise, if the work gets cancelled, an empty <code>std::optional&lt;...&gt;</code> is returned. In the example, the child sends a string which gets wrapped into a <code>std::tuple</code> which in turn gets wrapped into an <code>std::optional</code>. Thus, the somewhat round-about way to get the result: first using <code>value_or(std::tuple(""s))</code> to get the value from the <code>std::optional</code> which is then decomposed from the <code>std::tuple</code> using structured bindings.</li>
</ul>
<p></p>
</details>
<details >
<summary >
<code>"Hello, async"</code> - a simple asynchronous example</summary>
<p></p>
<p>Code: [<code>examples/intro-2-hello-async.cpp</code>]() </p><div class="fragment"><div class="line"><span class="comment">// examples/intro-2-hello-async.cpp                                   -*-C++-*-</span></div>
<div class="line"><span class="comment">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;beman/execution/execution.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;intro-timer.hpp&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;chrono&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;tuple&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>ex = ::beman::execution;</div>
<div class="line"><span class="keyword">using namespace </span>std::string_literals;</div>
<div class="line"><span class="keyword">using namespace </span>std::chrono_literals;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ----------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">// Please see the explanation in docs/intro-examples.md for an explanation.</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    std::cout &lt;&lt; std::unitbuf;</div>
<div class="line">    intro::timer timer;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// clang-format off</span></div>
<div class="line">     <span class="keyword">auto</span> [result] = ex::sync_wait(</div>
<div class="line">         ex::when_all(</div>
<div class="line">             timer.run(),</div>
<div class="line">             ex::when_all(</div>
<div class="line">                 timer.resume_after(3s)</div>
<div class="line">                     | ex::then([] { std::cout &lt;&lt; <span class="stringliteral">&quot;h\n&quot;</span>; return std::string(<span class="stringliteral">&quot;hello&quot;</span>); }),</div>
<div class="line">                 timer.resume_after(1s)</div>
<div class="line">                     | ex::then([] { std::cout &lt;&lt; <span class="stringliteral">&quot;,\n&quot;</span>; return std::string(<span class="stringliteral">&quot;, &quot;</span>); }),</div>
<div class="line">                 timer.resume_after(2s)</div>
<div class="line">                     | ex::then([] { std::cout &lt;&lt; <span class="stringliteral">&quot;w\n&quot;</span>; return std::string(<span class="stringliteral">&quot;world&quot;</span>); })</div>
<div class="line">             ) | ex::then([](<span class="keyword">auto</span> s1, <span class="keyword">auto</span> s2, <span class="keyword">auto</span> s3) { return s1 + s2 + s3; })</div>
<div class="line">         )</div>
<div class="line">     ).value_or(std::tuple(std::string(<span class="stringliteral">&quot;&quot;</span>)));</div>
<div class="line">    <span class="comment">// clang-format on</span></div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; result &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p></p>
</details>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
