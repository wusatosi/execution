<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>beman::execution: overview</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
 <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
 <script type="text/javascript">
     DoxygenAwesomeDarkModeToggle.init()
 </script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="beman-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">beman::execution
   </div>
   <div id="projectbrief">Building Block For Asynchronous Programs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_docs_overview.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">overview </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md2"></a>
std::execution Overview</h1>
<details >
<summary >
<code>scheduler&lt;<em>Scheduler</em>&gt;</code></summary>
<p>Schedulers are used to specify the execution context where the asynchronous work is to be executed.</p>
<p>A scheduler is a lightweight handle providing a <code><a href="‘#schedule’">schedule</a></code> operation yielding a <code><a href="‘#sender’">sender with a value completion signal</a> without parameters. The completion is on the respective execution context.</code></p>
<p><code>Requirements for <code><em>Scheduler</em></code>:</p><ul>
<li>The type <code><em>Scheduler</em>::scheduler_concept</code> is an alias for <code>scheduler_t</code> or a type derived thereof`.</li>
<li><code><a href="‘#schedule’">schedule</a>(<em>scheduler</em>) -&gt; <a href="‘sender’">sender</a></code></li>
<li>The <a href="‘#get-completion-scheduler’">value completion scheduler</a> of the <code><a href="‘sender’">sender</a></code>’s <a href="‘#environment’">environment</a> is the <code><em>scheduler</em></code>: <em>scheduler</em> == std::execution::get_completion_scheduler&lt;std::execution::set_value_t&gt;( std::execution::get_env(std::execution::schedule(<em>scheduler</em>)) )</li>
<li><code>std::equality_comparable&lt;<em>Scheduler</em>&gt;</code></li>
<li><code>std::copy_constructible&lt;<em>Scheduler</em>&gt;</code> </li>
</ul>
<p></code></p>
</details>
<p><code></p><details >
<summary >
<code>sender&lt;<em>Sender</em>&gt;</code></summary>
<p></p>
<p>Senders represent asynchronous work. They may get composed from multiple senders to model a workflow. Senders can’t be run directly. Instead, they are passed to a &lt;a href=‘::sender-consumer’ which <code><a href="‘#connect’">connect</a></code>s the sender to a <code><a href="‘#receiver’">receiver</a></code> to produce an <code><a href="‘#operation-state’">operation_state</a></code> which may get started. When using senders to represent work the inner workings shouldn’t matter. They do become relevant when creating sender algorithms.</p>
<p>Requirements for <code><em>Sender</em></code>:</p><ul>
<li>The type <code><em>Sender</em>::sender_concept</code> is an alias for <code>sender_t</code> or a type derived thereof or <code><em>Sender</em></code> is a suitable <em>awaitable</em>.</li>
<li><code><a href="get_env">std::execution::get_env</a>(<em>sender</em>)</code> is valid. By default this operation returns <code><a href="‘empty-env’">std::execution::empty_env</a></code>.</li>
<li>Rvalues of type <code><em>Sender</em></code> can be moved.</li>
<li>Lvalues of type <code><em>Sender</em></code> can be copied.</li>
</ul>
<p>Typical members for <code><em>Sender</em></code>:</p><ul>
<li><code><a href="‘get_env’">get_env</a>() const noexcept</code></li>
<li><code><a href="‘get_completion_signatures’">get_completion_signatures</a>(<em>env</em>) const noexcept -&gt; <a href="‘completion-signatures’">std::execution::completion_signatures</a>&lt;...&gt;</code></li>
<li><code><em>Sender</em>::completion_signatures</code> is a type alias for <code><a href="‘completion-signatures’">std::execution::completion_signatures</a>&lt;...&gt;</code> (if there is no <code><a href="‘get_completion_signatures’">get_completion_signatures</a></code> member).</li>
<li><code><a href="‘#connect’">connect</a>(<em>sender</em>, <a href="‘#receiver’">receiver</a>) -&gt; <a href="‘#operation-state’">operation_state</a></code></li>
</ul>
<details >
<summary >
Example</summary>
<p>The example shows a sender implementing an operation similar to <code><a href="‘#just’">just</a>(_value)</code>.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">struct example_sender</div>
<div class="line">{</div>
<div class="line">    template &lt;std::execution::receiver Receiver&gt;</div>
<div class="line">    struct state</div>
<div class="line">    {</div>
<div class="line">        using operation_state_concept = std::execution::operation_state_t;</div>
<div class="line">        std::remove_cvref_t&lt;Receiver&gt; receiver;</div>
<div class="line">        int                           value;</div>
<div class="line">        auto start() &amp; noexcept {</div>
<div class="line">            std::execution::set_value(</div>
<div class="line">                std::move(this-&gt;receiver),</div>
<div class="line">                this-&gt;value</div>
<div class="line">            );</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line">    using sender_concept = std::execution::sender_t;</div>
<div class="line">    using completion_signatures = std::execution::completion_signatures&lt;</div>
<div class="line">        std::execution::set_value_t(int)</div>
<div class="line">    &gt;;</div>
<div class="line"> </div>
<div class="line">    int value{};</div>
<div class="line">    template &lt;std::execution::receiver Receiver&gt;</div>
<div class="line">    auto connect(Receiver&amp;&amp; receiver) const -&gt; state&lt;Receiver&gt; {</div>
<div class="line">        return { std::forward&lt;Receiver&gt;(receiver), this-&gt;value };</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">static_assert(std::execution::sender&lt;example_sender&gt;);</div>
</div><!-- fragment --> </details>
</details>
<details >
<summary >
<code>sender_in&lt;<em>Sender, Env</em> = std::execution::empty_env&gt;</code></summary>
<p></p>
<p>The concept <code>sender_in&lt;<em>Sender, Env</em>&gt;</code> tests whether <code><em>Sender</em></code> is a <code><a href="‘#sender’">sender</a></code>, <code><em>Env</em></code> is a destructible type, and <code><a href="‘#get_completion_signatures’">std::execution::get_completion_signatures</a>(<em>sender</em>, <em>env</em>)</code> yields a specialization of <code><a href="‘#completion_signatures’">std::execution::completion_signatures</a></code>. </p>
</details>
<details >
<summary >
<code>sender_to&lt;<em>Sender, Receiver</em>&gt;</code></summary>
<p></p>
<p>The concept <code>sender_to&lt;<em>Sender, Receiver</em>&gt;</code> tests if <code><a href="‘#sender_in’">std::execution::sender_in</a>&lt;<em>Sender</em>, <a href="#env_of_t">std::execution::env_of_t</a>&lt;<em>Receiver</em>&gt;&gt;</code> is true, and if <code><em>Receiver</em></code> can receive all <a href="‘#completion-signals’">completion signals</a> which can be sent by <code><em>Sender</em></code>, and if <code><em>Sender</em></code> can be <code><a href="‘#connect’">connect</a></code>ed to <code><em>Receiver</em></code>.</p>
<p>To determine if <code><em>Receiver</em></code> can receive all <a href="‘#completion-signals’">completion signals</a> from <code><em>Sender</em></code> it checks that for each <code><em>Signature</em></code> in <code><a href="‘#get_completion_signals’">std::execution::get_completion_signals</a>(<em>sender</em>, std::declval&lt;<a href="#env_of_t">std::execution::env_of_t</a>&lt;<em>Receiver</em>&gt;&gt;())</code> the test <code><a href="‘#receiver_of’">std::execution::receiver_of</a>&lt;<em>Receiver</em>, <em>Signature</em>&gt;</code> yields true. To determine if <code><em>Sender</em></code> can be <code><a href="‘#connect’">connect</a></code>ed to <code><em>Receiver</em></code> the concept checks if <code><a href="‘#connect’">connect</a>(std::declval&lt;<em>Sender</em>&gt;(), std::declval&lt;<em>Receiver</em>&gt;)</code> is a valid expression. </p>
</details>
<details >
<summary >
<code>sends_stopped&lt;<em>Sender, Env</em> = std::execution::empty_env&gt;</code></summary>
<p></p>
<p>The concept <code>sends_stopped&lt;<em>Sender, Env</em>&gt;</code> determines if <code><em>Sender</em></code> may send a <code><a href="‘#set_stopped’">stopped</a></code> <a href="‘#completion-signals’">completion signal</a>. To do so, the concepts determines if <code><a href="‘#get_completion_signals’">std::execution::get_completion_signals</a>(<em>sender</em>, <em>env</em>)</code> contains the signatures <code><a href="‘#set_stopped’">std::execution::set_stopped_t</a>()</code>. </p>
</details>
<details >
<summary >
<code>stoppable_token&lt;<em>Token</em>&gt;</code></summary>
<p>A <code>stoppable_token&lt;<em>Token</em>&gt;</code>, e.g., obtained via <code><a href="‘#get-stop-token’">std::execution::get_stop_token</a>(<em>env</em>)</code> is used to support cancellation of asynchronous operations. Using <code><em>token</em>.stop_requested()</code> an active operation can poll whether it was requested to cancel. An inactive operation waiting for a notification can use an object of a specialization of the template <code><em>Token</em>::callback_type</code> to get notified when cancellation is requested.</p>
<p>Required members for <code><em>Token</em></code>:</p>
<ul>
<li><code><em>Token</em>::callback_type&lt;<em>Callback</em>&gt;</code> can be specialized with a <code>std::callable&lt;<em>Callback</em>&gt;</code> type.</li>
<li><code><em>token</em>.stop_requested() const noexcept -&gt; bool</code></li>
<li><code><em>token</em>.stop_possible() const noexcept -&gt; bool</code></li>
<li><code>std::copyable&lt;<em>Token</em>&gt;</code></li>
<li><code>std::equality_comparable&lt;<em>Token</em>&gt;</code></li>
<li><code>std::swapable&lt;<em>Token</em>&gt;</code> <blockquote class="doxtable">
<details >
<summary >
Example: concept use</summary>
<div></div><div><div class="fragment"><div class="line"> {c++}</div>
<div class="line">static_assert(std::execution::unstoppable_token&lt;std::execution::never_stop_token&gt;);</div>
<div class="line">static_assert(std::execution::unstoppable_token&lt;std::execution::stop_token&gt;);</div>
<div class="line">static_assert(std::execution::unstoppable_token&lt;std::execution::inline_stop_token&gt;);</div>
</div><!-- fragment --> </div> </details>
<details >
<summary >
Example: polling</summary>
<blockquote class="doxtable">
<p>This example shows a sketch of using a <code>stoppable_token&lt;<em>Token</em>&gt;</code> to cancel an active operation. The computation in this example is represented as <code>sleep_for</code>.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">void compute(std::stoppable_token auto token)</div>
<div class="line">{</div>
<div class="line">    using namespace std::chrono::literals;</div>
<div class="line">    while (not token.stop_requested()) {</div>
<div class="line">         std::this_thread::sleep_for(1s);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --> </blockquote>
</details>
<details >
<summary >
Example: inactive</summary>
<blockquote class="doxtable">
<p>This example shows how an <code><a href="‘#operation-state’">operation_state</a></code> can use the <code>callback_type</code> together with a <code><em>token</em></code> to get notified when cancellation is requested.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">template &lt;std::execution::receiver Receiver&gt;</div>
<div class="line">struct example_state</div>
<div class="line">{</div>
<div class="line">    struct on_cancel</div>
<div class="line">    {</div>
<div class="line">        example_state&amp; state;</div>
<div class="line">        auto operator()() const noexcept {</div>
<div class="line">            this-&gt;state.stop();</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line">    using operation_state_concept = std::execution::operation_state_t;</div>
<div class="line">    using env = std::execution::env_of_t&lt;Receiver&gt;;</div>
<div class="line">    using token = std::execution::stop_callback_of_t&lt;env&gt;;</div>
<div class="line">    using callback = std::execution::stop_callback_of_t&lt;token, on_cancel&gt;;</div>
<div class="line">    std::remove_cvref_t&lt;Receiver&gt; receiver;</div>
<div class="line">    std::optional&lt;callback&gt;       cancel{};</div>
<div class="line">    std::atomic&lt;std::size_t&gt;      outstanding{};</div>
<div class="line">    auto start() &amp; noexcept {</div>
<div class="line">        this-&gt;outstanding += 2u;</div>
<div class="line">        this-&gt;cancel.emplace(</div>
<div class="line">            std::execution::get_stop_token(this-&gt;receiver),</div>
<div class="line">            on_cancel{*this}</div>
<div class="line">        );</div>
<div class="line">        if (this-&gt;outstanding != 2u)</div>
<div class="line">           std::execution::set_stopped(std::move(this-&gt;receiver));</div>
<div class="line">        else {</div>
<div class="line">           register_work(this);</div>
<div class="line">           if (this-&gt;outstanding == 0u)</div>
<div class="line">               std::execution::set_value(std::move(this-&gt;receiver));</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    auto stop() {</div>
<div class="line">        unregister_work(this);</div>
<div class="line">        if (--this-&gt;outstanding == 0u)</div>
<div class="line">            std::execution::set_stopped(std::move(this-&gt;receiver));</div>
<div class="line">    }</div>
<div class="line">    auto complete() {</div>
<div class="line">        if (this-&gt;outstanding == 2u) {</div>
<div class="line">            this-&gt;cancel.reset();</div>
<div class="line">            std::execution::set_value(std::move(this-&gt;receiver));</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --> </blockquote>
</details>
</blockquote>
</li>
</ul>
</details>
<details >
<summary >
<code>unstoppable_token&lt;<em>Token</em>&gt;</code></summary>
<p>The concept <code>unstoppable_token&lt;Token&gt;</code> is modeled by a <code><em>Token</em></code> if <code>stoppable_token&lt;<em>Token</em>&gt;</code> is true and it can statically be determined that both <code><em>token</em>.stop_requested()</code> and <code><em>token</em>.stop_possible()</code> are <code>constexpr</code> epxressions yielding <code>false</code>. This concept is primarily used to avoid extra work when using stop tokens which will never indicate that cancellations are requested. </p><blockquote class="doxtable">
<details >
<summary >
Example</summary>
<p>The concept yields <code>true</code> for the <code><a href="‘#never-stop-token’">std::execution::never_stop_token</a></code>:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">static_assert(std::execution::unstoppable_token&lt;std::execution::never_stop_token&gt;);</div>
<div class="line">static_assert(not std::execution::unstoppable_token&lt;std::execution::stop_token&gt;);</div>
<div class="line">static_assert(not std::execution::unstoppable_token&lt;std::execution::inline_stop_token&gt;);</div>
</div><!-- fragment --> </details>
</blockquote>
</details>
<p></code></p>
<p><code></code></p>
<h2><a class="anchor" id="autotoc_md3"></a>
Queries</h2>
<p><code>The queries are used to obtain properties associated with and object. Except <code><a href="‘#forwarding-query’">forwarding_query</a></code> and <code><a href="‘#get-env’">get_env</a></code> the queries work on <a href="‘#environment’">environments</a>.</code></p>
<p><code></p><details >
<summary >
<code>forwarding_query(<em>query</em>) -&gt; bool</code></summary>
<p></p>
</details>
<details >
<summary >
<code>get_env(<em>queryable</em>)</code></summary>
<p></p>
</details>
<details >
<summary >
<code>get_allocator(<em>env</em>)</code></summary>
<p></p>
</details>
<details >
<summary >
<code>get_completion_scheduler(<em>env</em>)</code></summary>
<p></p>
</details>
<details >
<summary >
<code>get_completion_signatures(<em>sender</em>, <em>env</em>)</code></summary>
<p></p>
</details>
<details >
<summary >
<code>get_delegation_scheduler(<em>env</em>)</code></summary>
<p></p>
</details>
<details >
<summary >
<code>get_domain(<em>env</em>)</code></summary>
<p></p>
<p></p>
</details>
<details >
<summary >
<code>get_forward_progress_guarantee(<em>env</em>)</code></summary>
<p></p>
</details>
<details >
<summary >
<code>get_scheduler(<em>env</em>)</code></summary>
<p></p>
</details>
<details >
<summary >
<code>get_stop_token(<em>env</em>)</code></summary>
<p></p>
</details>
<p></code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md4"></a>
Customization Point Objects</h3>
<p><code></p><ul>
<li><code>connect(<em>sender, receiver</em>) -&gt; <em>operation_state</em></code></li>
<li><code>set_error(<em>error</em>) noexcept -&gt; void</code></li>
<li><code>set_stopped(<em>receiver</em>) noexcept -&gt; void</code></li>
<li><code>set_value(<em>receiver, value...</em>) noexcept -&gt; void</code></li>
<li><code>start(<em>state&amp;</em>) noexcept -&gt; void</code></li>
</ul>
<p></code></p>
<p><code></code></p>
<h2><a class="anchor" id="autotoc_md5"></a>
Senders</h2>
<p><code> </code></p>
<h3><a class="anchor" id="autotoc_md6"></a>
Sender Factories</h3>
<p><code></p><ul>
<li><code>just(<em>value...</em>) -&gt; <em>sender-of</em>&lt;set_value_t(<em>Value...</em>)&gt;</code></li>
<li><code>just_error(<em>error</em>) -&gt; <em>sender-of</em>&lt;set_error_t(<em>Error</em>)&gt;</code></li>
<li><code>just_stopped() -&gt; <em>sender-of</em>&lt;set_stopped_t()&gt;</code></li>
<li><code>read_env(<em>query</em>) -&gt; <em>sender-of</em>&lt;set_value_t(<em>query-result</em>)&gt;</code></li>
<li><code>schedule(<em>scheduler</em>) -&gt; <em>sender-of</em>&lt;set_value_t()&gt;</code></li>
</ul>
<p></code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md7"></a>
Sender Adaptors</h3>
<p><code></p><ul>
<li><code>bulk</code></li>
<li><code>continues_on(<em>sender</em>, <em>scheduler</em>) -&gt; <em>sender</em></code></li>
<li><code>into_variant(<em>sender</em>) -&gt; <em>sender-of</em>&lt;set_value_t(std::variant&lt;T...&gt;)&gt;</code>`</li>
<li><code>let_error(<em>upstream</em>, <em>fun</em>) -&gt; <em>sender</em></code></li>
<li><code>let_stopped(<em>upstream</em>, <em>fun</em>) -&gt; <em>sender</em></code></li>
<li><code>let_value(<em>upstream</em>, <em>fun</em>) -&gt; <em>sender</em></code></li>
<li><code>on</code></li>
<li><code>schedule_from(<em>scheduler</em>, <em>sender</em>) -&gt; <em>sender</em></code></li>
<li><code>split</code></li>
<li><code>starts_on(<em>scheduler</em>, <em>sender</em>) -&gt; <em>sender</em></code></li>
<li><code>stopped_as_error</code></li>
<li><code>stopped_as_optional</code></li>
<li><code>then(<em>upstream</em>, <em>fun</em>) -&gt; <em>sender</em></code></li>
<li><code>upon_error(<em>upstream</em>, <em>fun</em>) -&gt; <em>sender</em></code></li>
<li><code>upon_stopped(<em>upstream</em>, <em>fun</em>) -&gt; <em>sender</em></code></li>
<li><code>when_all(<em>sender</em>...) -&gt; <em>sender</em></code></li>
<li><code>when_all_with_variant(<em>sender</em>...) -&gt; <em>sender</em></code></li>
</ul>
<p></code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md8"></a>
Sender Consumers</h3>
<p><code></p><ul>
<li><code>sync_wait(<em>sender</em>) -&gt; std::optional&lt;std::tuple&lt;T...&gt;&gt;</code></li>
</ul>
<p></code></p>
<p><code></code></p>
<h2><a class="anchor" id="autotoc_md9"></a>
Helpers</h2>
<p><code></p><ul>
<li><code>as_awaitable</code></li>
<li><code>with_awaitable_sender</code></li>
<li><code>apply_sender</code></li>
<li><code>completion_signatures</code></li>
<li><code>completion_signatures_t</code></li>
<li><code>connect_result_t</code></li>
<li><code>default_domain</code></li>
<li><code>empty_env</code></li>
<li><code>env_of_t</code></li>
<li><code>error_types_of_t</code></li>
<li><code>fwd_env</code></li>
<li><code>operation_state_t</code></li>
<li><code>receiver_t</code></li>
<li><code>run_loop</code></li>
<li><code>scheduler_t</code></li>
<li><code>schedule_result_t</code></li>
<li><code>sender_adaptor_closure</code></li>
<li><code>sender_t</code></li>
<li><code>stop_token_of_t</code></li>
<li><code>tag_of_t</code></li>
<li><code>transform_sender</code></li>
<li><code>transform_completion_signatures</code></li>
<li><code>transform_completion_signatures_of</code></li>
<li><code>value_types_of_t</code></li>
</ul>
<p></code></p>
<p><code></code></p>
<h2><a class="anchor" id="autotoc_md10"></a>
Stop Token</h2>
<p><code></p><ul>
<li><code>never_stop_token</code></li>
<li><code>stop_token</code></li>
<li><code>inplace_stop_token</code> </li>
</ul>
<p></code></p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
